
### 배열을 끝까지 다 돌면서 작은 애를 앞으로 보내는 작업의 반복

`[ 10, 5, 8, 2, 3, 9, 1, 4, 6, 7 ]` 이런 숫자들이 있다고 해보자.

+ `[ 10, 5, 8, 2, 3, 9, 1 ,4, 6 ,7 ]` 다 돌면서 가장 작은 값을 찾고, 그 수를 맨 앞의 숫자와 바꾼다.
+ `[ 1, 5, 8, 2, 3, 9 ,10 ,4 ,6 ,7 ]` 의 결과가 나왔다. 여기서 정렬 완료된 숫자(1)를 제외한 나머지 수에 대해 다시 돌면서 가장 작은 값을 찾고, 그 수를 맨 앞의 숫자와 바꾼다.
+ `[ 1, 2, 8, 5, 3, 9, 10 ,4 ,6 ,7 ]` 의 결과가 나왔다. 여기서 정렬 완료된 숫자(1,2)를 제외한 나머지 수에 대해 다시 돌면서 가장 작은 값을 찾고, 그 수를 맨 앞의 숫자와 바꾼다.
+ `[ 1, 2, 3, 5, 8, 9 ,10, 4, 6, 7 ]` 의 결과가 나왔다. ... 반복

### (오름차순) 선택정렬 예시
```c
void swap(int* x, int* y);
void printArr(int arr[], int size);
```
```c
int main()
{
	int min, idx;
	int arr[10] = { 10,5,8,2,3,9,1,4,6,7 };

	for (int i = 0; i <10; i++) {
		// 배열을 돌면서 최소값을 잡아주기 위해 절대적으로 큰 값을 초기화
		min = 999;
		for (int j = i; j < 10; j++) {
			// 가장 작은 값 찾고 그 값의 index를 기억해둠.
			if (min > arr[j]) {
						// min(최소값)이 arr[j]보다 크다면, 더 이상 min은 최소값이 아니다.
				min = arr[j];   // 이제 최소값은 arr[j]이다.
				idx = j;  	// 최소값이 있는 위치(index j)를 기억
			}
		}
		// 가장 작은 값 찾는 반복이 끝나면 그 결과를 바탕으로 swap 실행
		// 가장 작은 값을 맨 앞으로 이동(반복의i번째랑 순서 바꿈).
		swap(&arr[i], &arr[idx]);

	}
	printArr(arr, 10);

	return 0;
}
```
```c
void swap(int* x, int* y) {
	int temp = *x;
	*x = *y;
	*y = temp;
}

void printArr(int arr[], int size) {
	for (int i = 0; i < size; i++) {
		printf("%d ", arr[i]);
	}
}
```

### 시간복잡도는 O(N^2)
```
처음 10개를 돌고 정렬, 그 다음 9개 돌고 정렬, 8개 돌고 정렬, ... 마지막 까지 돌고 정렬
10 + 9 + 8 + ... + 2 + 1 = 10(10+1)/2
N(N+1)/2 => N^2
```
