### 바로 옆의 것과 비교하며 숫자를 바꿔가는 작업의 반복
```
버블정렬은 당장 바로 옆에있는 값이랑 비교해서
작은 값을 앞으로 보내는 작업의 반복
정렬 알고리즘 중 가장 효율성이 떨어짐

(오름차순)
바로 옆의 수와 비교해서 작은 값을 왼쪽, 큰 값을 오른쪽으로 바꾼다.
이 과정을 처음에는 배열 끝까지 쭉 진행한다.
반복이 1회 끝나면, 배열 내의 가장 큰 값이 맨 오른쪽으로 옮겨져있을 것.
그럼 정렬된 숫자를 제외하고 다시 반복을 시작한다.
1부터n-1까지, 1부터n-2까지, 1부터n-3까지 .... 1부터2까지

[ 10, 5, 8, 2, 3, 9, 1, 4, 6, 7 ] 이런 숫자들이 있다고 해보자.
[ 5, 10, 8, 2, 3, 9, 1, 4, 6, 7 ] // 5,10 바꿈
[ 5, 8, 10, 2, 3, 9, 1, 4, 6, 7 ] // 8,10 바꿈
... 
[ 5, 8, 2, 3, 9, 1, 4, 6, 7, 10 ] // 여기 까지가 1회 사이클. 한 바퀴 돌았으니 이걸 9번 더 한다.
```
(오름차순) 버블정렬 예시
```c
for (i = 0; i < 10; i++) {
	for (j = 0; j < 9 - i; j++) { // 반복의 범위가 끝에서부터 한칸 씩 점점 줄어드니까
		if (arr[j] > arr[j + 1]) { // 지금꺼가 다음꺼보다 크다면, swap할 예정
			// swap
		}
	}
}
// print array
```
### 시간복잡도는 O(N^2)
```
1에서부터 10까지, 1에서부터 9까지, 1에서부터 8까지, ... 얘도 10+9+8+7+...+1 이니까 O(N^2)이다.
빅오는 선택정렬과 같지만 직접 돌려보면 선택정렬보다 느리다.
버블정렬이 temp를 이용해서 값을 바꿔주는 행위를 더 많이 하기 때문
(선택정렬은 반복 돌리고 스왑하지만, 버블정렬은 옆에꺼랑 계속 비교하면서 스왑,비교->스왑.. 계속 하니까)
```
